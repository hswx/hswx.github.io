---
title: 快速排序
date: 2017-11-03 12:03:05
tags: ["排序算法","快速排序"]
---

# 1 算法原理

快速排序是找出一个元素（理论上可以随便找一个）作为基准(pivot),然后对数组进行分区操作,使基准左边元素的值都不大于基准值,基准右边的元素值 都不小于基准值，如此作为基准的元素调整到排序后的正确位置。递归快速排序，将其他n-1个元素也调整到排序后的正确位置。最后每个元素都是在排序后的正 确位置，排序完成。所以快速排序算法的核心算法是分区操作，即如何调整基准的位置以及调整返回基准的最终位置以便分治递归。

举例说明一下吧，这个可能不是太好理解。假设要排序的序列为

2 2 4 9 3 6 7 1 5 首先用2当作基准，使用i j两个指针分别从两边进行扫描，把比2小的元素和比2大的元素分开。首先比较2和5，5比2大，j左移

2 2 4 9 3 6 7 1 5 比较2和1，1小于2，所以把1放在2的位置

2 1 4 9 3 6 7 1 5 比较2和4，4大于2，因此将4移动到后面

2 1 4 9 3 6 7 4 5 比较2和7，2和6，2和3，2和9，全部大于2，满足条件，因此不变

经过第一轮的快速排序，元素变为下面的样子

[1] 2 [4 9 3 6 7 5]

之后，在把2左边的元素进行快排，由于只有一个元素，因此快排结束。右边进行快排，递归进行，最终生成最后的结果。

# 2 算法分析

时间复杂度：O( nlogn )，不稳定

# 3 算法实现

	/**
	 * 
	 * @param array 无序数组    
	 * @param left 左起点
	 * @param right 右起点
	 */
	
	function kuaisu(array,left,right) {
	    let _left=left;
	    let _right=right;
	    if(left<right) {
	        let tmp = array[right];
	        while (left < right) {
	            while (left < right && array[left] <= tmp) {
	                left++;
	            }
	            array[right] = array[left];
	            while (left < right && array[right] >= tmp) {
	                right--;
	            }
	            array[left] = array[right];
	
	            array[right] = tmp;
	        }
	        kuaisu(array,_left,right-1);
	        kuaisu(array,left+1,_right);
	    }
	}

