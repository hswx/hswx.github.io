---
title: 浅拷贝和深拷贝
date: 2017-11-27 18:18:53
tags: ["浅拷贝","深拷贝"]
---
 
# 为什么要进行浅/深拷贝

JavaScript语言中，数据的类型有两种，一种是值类型，保存在栈中，一种是引用类型，保存在堆中。值类型保存和传递的是变量的值，而引用类型保存和传递的是变量的引用，传递之后的变量和传递之前的变量引用的是同一块内存保存的数据，就会产生下面的情况。当我们修改某一引用类型的变量时候，指向这块内存的所有的变量的值都会改变。

	var m={a:1};
	var n=m;
	n.a=2;
	console.log(m.a); // 2

# 浅/深拷贝的区别

对于基本数据类型/值类型（string、number、boolean、undefined、null），浅复制是对值的复制。对于复杂数据类型/引用类型object来说，浅复制是对对象地址的复制，并没有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变，而深复制则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。

# 浅拷贝的实现

浅复制只复制一层对象的属性，要注意的是，这里通过for...in的方式获取第一层属性，有可能拿到对象可枚举的原型属性，通过Object.hasOwnProperty()来判断是否是对象自身的属性。当然，也可以通过Object.keys()获取对象自身的属性来遍历。

	function shallowCopy(obj) {
	    var result = {};
	    for (let key in obj) {
	        if (obj.hasOwnProperty(key)) {
	            result[key] = obj[key];
	        }
	    }
	    return result;
	}

# 深拷贝的实现

深拷贝需要开辟新的地址，把被复制对象的所有层级都复制过来，目前深复制通常有两种方式，第一种借用JSON.stringify和JSON.parse来做：

	 JSON.parse( JSON.stringify(obj))
	 
这种方式在一些简单的应用场景中比较方便，但是存在一些问题，比如当对象中存在引用自身的情况，var obj={a:1,b:obj}，JSON的转换会报错，JSON无法转换Regx

	function deepCopy(obj, finalRes) {
	    var res = finalRes || {};
	    for (var i in obj) {
	        var prop = obj[i];
	        if(prop === res) { // 这里防止obj对象中的属性值也是obj导致死循环
	            continue;
	        }
	        if (typeof prop === 'object') {
	            res[i] = (prop.constructor === Array) ? [] : {}; 
	            deepCopy(prop, res[i]);
	        } else { // prop是基本类型或者是function的情况下
	            res[i] = prop;
	        }
	    }
	    return res;
	}